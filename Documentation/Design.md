
**FabricObserver** is a lightweight *Stateless Service Fabric service* which is designed to be highly decoupled from the underlying Fabric system services it observes. We do not rely on interaction with internal-only Service Fabric subsystems beyond what we can access through a public API, like all Service Fabric Service implementations in the public domain\... This is a design decision to limit runtime dependencies and enable agile delivery of bug fixes and new features for Observers (and in time, Healers or Mitigators). We do not need to align with the delivery plans for the underlying system. There is no need for FabricObserver to maintain replicated internal state, so we don't need to implement Fabric Observer as a Stateful Service Fabric service today. 

FO is implemented using Service Fabricâ€™s public API surface only. It does not ship with SF. It is independent of the SF runtime engineering schedule.

There is no need for FabricObserver to run with elevated privileges. It is runs as Network Service. FabricObserver does not need or use much CPU, Working Set or Disk space (depending on configuration - CSV files can add up if you choose to store long running data locally.). FabricObserver does not listen on any ports. The only way to access information generated by FO is use the node-local (default impl) FabricObserverWebApi service, which is not accessible from the Internet, by default (you can choose to change that), but is readily available from the node. So, your service can easily query FO observer states by making a REST call to a localhost URI (port 5000 by default. Configurable...), which will return a JSON blob describing health state for said observer. You can read more about
this in the [FabricObserverWeb ReadMe](/FabricObserverWeb/ReadMe.md) 

***FabricObserver Components***  


**ObserverManager** serves as the entry point for creating and managing all Observers.
Its RunObservers method calls ObserveAsync on all the Observer instances in a
sequential loop with a configurable sleep between cycles.

The iteration interval defaults to 0 seconds (no sleep). The sleep setting is
user-configurable in Settings.xml. ObserverManager manages the lifetime of
observers and will dispose of them in addition to stopping their
execution when shutdown or task cancellation is requested. You can stop an observer
by calling ObserverManager's StopObservers() function.


**ObserverBase**  

This is the abstract base class for all Observers. It provides several concrete method and property implementations 
that are widely used by deriving types, not the least of which is ProcessResourceDataReportHealth(), which is called from all
observers' ReportAsync function.

***Design*** 

IObserver and IObserverBase interfaces (implemented/abstracted by ObserverBase, which is
implemented by all Observers)  
```C#
    
public interface IObserver : IDisposable
{
	DateTime LastRunDateTime { get; set; }
	TimeSpan RunInterval { get; set; }
	bool IsEnabled { get; set; }
	bool HasActiveFabricErrorOrWarning { get; set; }
	bool IsUnhealthy { get; set; }
	Task ObserveAsync(CancellationToken token);
	Task ReportAsync(CancellationToken token);
}

public interface IObserverBase<TServiceContext> : IObserver
{
	string ObserverName { get; set; }
	string NodeName { get; set; }
	ObserverHealthReporter HealthReporter { get; }
	// StatefulServiceContext or StatelessServiceContext...
	TServiceContext FabricServiceContext { get; }
	Logger ObserverLogger { get; set; }
	DataTableFileLogger CsvFileLogger { get; set; }
	void WriteToLogWithLevel(string observerName, string description, LogLevel level);
	TimeSpan GetObserverRunInterval(string configSectionName, string configParamName, TimeSpan? defaultTo = null);
	string GetSettingParameterValue(string sectionName, string parameterName, string defaultValue = null);
	IDictionary<string, string> GetConfigSettingSectionParameters(string sectionName);
}
    

public abstract class ObserverBase : IObserverBase<StatelessServiceContext>
{
	...
}
```

An ObserverBase-derived type must implement:

-   An internal constructor of shape: \[Some\]Observer() **:
    base(\[ObserverName\])** { }

-   A Task ObserveAsync(CancellationToken token) method

-   A Task ReportAsync(CancellationToken token) method

***The Observer***

An **Observer** is a C\# object that is instantiated inside a Stateless
Service Fabric Service process. An Observer is designed to monitor
specific machine level resource conditions, SF App properties, SF service properties, SF config and runtime properties.
For resource usage, the metrics are stored in in-memory data structures for use in reporting.

An Observer must support the following properties and behaviors:

-   Easily extensible monitoring "framework": developers should be able
    to readily add new types of data collectors to an observer

-   Ability to observe Machine, SF System Services, and user service health

-   Observers must be low cost and highly effective: Process of
    observation **does not add significant resource pressure** to nodes
    (VMs).

-   Health data collected by Observers must be easily queried with
    results that are immediately useful to users such that they can make
    informed mitigation decisions, should they choose to do so.


Each Observer can create a Warning if some metric exceeds a supplied
threshold. **Note: Fabric Health Errors will not be generated by default as this will block
runtime upgrades, etc -- and further, this breaks the guarantee that
FabricObserver will have no side effects on Service Fabric's systemic
behavior. Generating Health Errors is **YOUR** decision and it's fine to do it as long as you understand what it means...**. 
A Health report lives for a calculated duration. This ensures that the Fabric Health report remains
active until the next time the related observer runs, which will either
clear the warning by sending an OK health report to Fabric or sending another
warning/error report to Fabric that lives for the calculated TTL. Each observer can call ObserverBase's SetTimeToLiveWarning function,
optionally providing an integer value that represents some timeout or computed run time, in seconds, the observer self-manages.

```C#
public TimeSpan SetTimeToLiveWarning(int runDuration = 0)
{
    // Set TTL...
    if (this.LastRunDateTime == DateTime.MinValue) // First run...
    {
	return TimeSpan.FromSeconds(ObserverManager.ObserverExecutionLoopSleepSeconds)
			 .Add(TimeSpan.FromMinutes(TTLAddMinutes));
    }
    else
    {
	return DateTime.Now.Subtract(this.LastRunDateTime)
	       	.Add(TimeSpan.FromSeconds(runDuration))
	       	.Add(TimeSpan.FromSeconds(ObserverManager.ObserverExecutionLoopSleepSeconds));
    }
} 
```

Let's look at the simple design of an Observer:
```c#
using System;
using System.Fabric;
using System.Fabric.Health;
using System.IO;
using System.Threading.Tasks;
using System.Threading;
using FabricObserver.Utilities;

namespace FabricObserver
{
	pubic class SomeObserver : ObserverBase
	{
		 public SomeObserver() : base(ObserverConstants.SomeObserverName) { }
		
		 public override DateTime LastRunDateTime { get; set; } = DateTime.MinValue;
		 
		 public override async Task ObserveAsync(CancellationToken token)
	 	 {
			 // Observe then call ReportAsync...
		 }
		
		 public override async Task ReportAsync(CancellationToken token)
		 {
			 // Prepare observational data to send to ObserverBase's ProcessResourceDataReportHealth function...
		 }
	 }	
 }
 ```

**Data Design**

Each observer is tasked with recording one or more metrics that are
relevant to local Machine health. Each metric will be stored in an
in-memory data structure (List\<T\> or some other generic collection
type) on the observer type, specified as a private instance field. These
values will be used to decide actionable (useful for mitigation)
alerting strategy (time based, standard deviation, min and max
thresholds).\
\
**Basic Output**

Log files containing time-based INFO, DEBUG, ERROR, and WARNING
information. INFO and DEBUG are written only in DEBUG builds for
development purposes. Only ERROR and WARNING states are signaled to
Fabric and logged locally. Some observers also output CSV files
containing related resource usage data across all iterations for use in
analysis, a long-running view of their behavior as it pertains to
resource consumption across CPU Time, Workingset, DiskIO. Peak and
Average usage is computed and stored. Each CSV is archived after 24
hours to limit file sizes.\
\
Fabric Health Reports for surfacing WARNING and ERROR states to users in
SFX. We will be diligent in not abusing Service Fabric Health store and
reporting. These states are preserved in memory across observation
iterations and if the state has settled back to Ok (normal), we will
fire off a health report with a *HealthState.Ok* to clear SFX
Error/Warning assuming expiration time has not already been reached. We
could maintain this in memory as well, and only send an Ok report if we
need to.
